/********************************************************************************
 * Copyright (c) 2017-2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
/**
 * A Point is composed of the (x,y) coordinates of an object.
 */
export interface Point {
    readonly x: number;
    readonly y: number;
}
export declare namespace Point {
    /**
     * (x,y) coordinates of the origin.
     */
    const ORIGIN: Point;
    /**
     * Adds two points.
     * @param {Point} p1 - First point
     * @param {Point} p2 - Second point
     * @returns {Point} The sum of the two points
     */
    function add(p1: Point, p2: Point): Point;
    /**
     * Subtracts two points.
     * @param {Point} p1 - First point
     * @param {Point} p2 - Second point
     * @returns {Point} The difference of the two points
     */
    function subtract(p1: Point, p2: Point): Point;
    /**
     * Specifies whether a point has exactly the same coordinates as another point.
     * @param {Point} point1 a point
     * @param {Point} point2 another point
     * @returns {boolean} `true` if `point1` has exactly the same `x` and `y` values as `point2`, `false` otherwise.
     */
    function equals(point1: Point, point2: Point): boolean;
    /**
     * Computes a point that is the original `point` shifted towards `refPoint` by the given `distance`.
     * @param {Point} point - Point to shift
     * @param {Point} refPoint - Point to shift towards
     * @param {Point} distance - Distance to shift
     */
    function shiftTowards(point: Point, refPoint: Point, distance: number): Point;
    /**
     * Computes the normalized vector from the vector given in `point`; that is, computing its unit vector.
     * @param {Point} point - Point representing the vector to be normalized
     * @returns {Point} The normalized point
     */
    function normalize(point: Point): Point;
    /**
     * Computes the magnitude of the vector given in `point`.
     * @param {Point} point - Point representing the vector to compute the magnitude for
     * @returns {number} The magnitude or also known as length of the `point`
     */
    function magnitude(point: Point): number;
    /**
     * Calculates a linear combination of p0 and p1 using lambda, i.e.
     *   (1-lambda) * p0 + lambda * p1
     */
    function linear(p0: Point, p1: Point, lambda: number): Point;
    /**
     * Returns the "straight line" distance between two points.
     * @param {Point} a - First point
     * @param {Point} b - Second point
     * @returns {number} The Eucledian distance
     */
    function euclideanDistance(a: Point, b: Point): number;
    /**
     * Returns the distance between two points in a grid, using a
     * strictly vertical and/or horizontal path (versus straight line).
     * @param {Point} a - First point
     * @param {Point} b - Second point
     * @returns {number} The Manhattan distance
     */
    function manhattanDistance(a: Point, b: Point): number;
    /**
     * Returns the maximum of the horizontal and the vertical distance.
     * @param {Point} a - First point
     * @param {Point} b - Second point
     * @returns {number} The maximum distance
     */
    function maxDistance(a: Point, b: Point): number;
    /**
     * Returns the dot product of two points.
     * @param {Point} a - First point
     * @param {Point} b - Second point
     * @returns {number} The dot product
     */
    function dotProduct(a: Point, b: Point): number;
}
/**
 * Computes the angle in radians of the given point to the x-axis of the coordinate system.
 * The result is in the range [-pi, pi].
 * @param {Point} p - A point in the Eucledian plane
 */
export declare function angleOfPoint(p: Point): number;
/**
 * Computes the angle in radians between the two given points (relative to the origin of the coordinate system).
 * The result is in the range [0, pi]. Returns NaN if the points are equal.
 * @param {Point} a - First point
 * @param {Point} b - Second point
 */
export declare function angleBetweenPoints(a: Point, b: Point): number;
/**
 * Computes the center of the line segment spanned by the two given points.
 * @param {Point} s - Start point of the line
 * @param {Point} e - End point of the line
 */
export declare function centerOfLine(s: Point, e: Point): Point;
/**
 * The Dimension of an object is composed of its width and height.
 */
export interface Dimension {
    readonly width: number;
    readonly height: number;
}
export declare namespace Dimension {
    /**
     * A dimension with both width and height set to a negative value, which is considered as undefined.
     */
    const EMPTY: Dimension;
    /**
     * Checks whether the given dimention is valid, i.e. the width and height are non-zero.
     * @param {Dimension} b - Dimension object
     * @returns {boolean} `true` if the dimension is valid
     */
    function isValid(d: Dimension): boolean;
}
/**
 * The bounds are the position (x, y) and dimension (width, height) of an object.
 */
export interface Bounds extends Point, Dimension {
}
export declare function isBounds(element: unknown): element is Bounds;
export declare namespace Bounds {
    const EMPTY: Bounds;
    /**
     * Combines the bounds of two objects into one, so that the new bounds
     * are the minimum bounds that covers both of the original bounds.
     * @param {Bounds} b0 - First bounds object
     * @param {Bounds} b1 - Second bounds object
     * @returns {Bounds} The combined bounds
     */
    function combine(b0: Bounds, b1: Bounds): Bounds;
    /**
     * Translates the given bounds.
     * @param {Bounds} b - Bounds object
     * @param {Point} p - Vector by which to translate the bounds
     * @returns {Bounds} The translated bounds
     */
    function translate(b: Bounds, p: Point): Bounds;
    /**
     * Returns the center point of the bounds of an object
     * @param {Bounds} b - Bounds object
     * @returns {Point} the center point
     */
    function center(b: Bounds): Point;
    /**
    * Checks whether the point p is included in the bounds b.
    */
    function includes(b: Bounds, p: Point): boolean;
}
/**
 * Converts from radians to degrees
 * @param {number} a - A value in radians
 * @returns {number} The converted value
 */
export declare function toDegrees(a: number): number;
/**
 * Converts from degrees to radians
 * @param {number} a - A value in degrees
 * @returns {number} The converted value
 */
export declare function toRadians(a: number): number;
/**
 * Returns whether two numbers are almost equal, within a small margin (0.001)
 * @param {number} a - First number
 * @param {number} b - Second number
 * @returns {boolean} True if the two numbers are almost equal
 */
export declare function almostEquals(a: number, b: number): boolean;
//# sourceMappingURL=geometry.d.ts.map