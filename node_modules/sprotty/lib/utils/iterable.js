"use strict";
/********************************************************************************
 * Copyright (c) 2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapIterable = exports.filterIterable = exports.DONE_RESULT = exports.toArray = exports.FluentIterableImpl = void 0;
/**
 * A helper class that allows to easily create fluent iterables.
 */
class FluentIterableImpl {
    constructor(startFn, nextFn) {
        this.startFn = startFn;
        this.nextFn = nextFn;
    }
    [Symbol.iterator]() {
        const iterator = {
            state: this.startFn(),
            next: () => this.nextFn(iterator.state),
            [Symbol.iterator]: () => iterator
        };
        return iterator;
    }
    filter(callback) {
        return filterIterable(this, callback);
    }
    map(callback) {
        return mapIterable(this, callback);
    }
    forEach(callback) {
        const iterator = this[Symbol.iterator]();
        let index = 0;
        let result;
        do {
            result = iterator.next();
            if (result.value !== undefined)
                callback(result.value, index);
            index++;
        } while (!result.done);
    }
    indexOf(element) {
        const iterator = this[Symbol.iterator]();
        let index = 0;
        let result;
        do {
            result = iterator.next();
            if (result.value === element)
                return index;
            index++;
        } while (!result.done);
        return -1;
    }
}
exports.FluentIterableImpl = FluentIterableImpl;
/**
 * Converts a FluentIterable into an array. If the input is an array, it is returned unchanged.
 */
function toArray(input) {
    if (input.constructor === Array) {
        return input;
    }
    const result = [];
    input.forEach(element => result.push(element));
    return result;
}
exports.toArray = toArray;
exports.DONE_RESULT = Object.freeze({ done: true, value: undefined });
/**
 * Create a fluent iterable that filters the content of the given iterable or array.
 */
function filterIterable(input, callback) {
    return new FluentIterableImpl(() => createIterator(input), (iterator) => {
        let result;
        do {
            result = iterator.next();
        } while (!result.done && !callback(result.value));
        return result;
    });
}
exports.filterIterable = filterIterable;
/**
 * Create a fluent iterable that maps the content of the given iterable or array.
 */
function mapIterable(input, callback) {
    return new FluentIterableImpl(() => createIterator(input), (iterator) => {
        const { done, value } = iterator.next();
        if (done)
            return exports.DONE_RESULT;
        else
            return { done: false, value: callback(value) };
    });
}
exports.mapIterable = mapIterable;
/**
 * Create an iterator for the given iterable or array.
 */
function createIterator(collection) {
    const method = collection[Symbol.iterator];
    if (typeof method === 'function') {
        return method.call(collection);
    }
    const length = collection.length;
    if (typeof length === 'number' && length >= 0) {
        return new ArrayIterator(collection);
    }
    return { next: () => exports.DONE_RESULT };
}
/**
 * Iterator implementation for arrays.
 */
class ArrayIterator {
    constructor(array) {
        this.array = array;
        this.index = 0;
    }
    next() {
        if (this.index < this.array.length)
            return { done: false, value: this.array[this.index++] };
        else
            return exports.DONE_RESULT;
    }
    [Symbol.iterator]() {
        return this;
    }
}
//# sourceMappingURL=iterable.js.map