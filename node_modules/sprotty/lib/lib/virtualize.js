"use strict";
/********************************************************************************
 * Copyright (c) 2017-2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
const snabbdom_1 = require("snabbdom");
function buildVNodeData(attrs) {
    const data = {};
    const addData = (memo, name) => {
        if (name !== 'style' && name !== 'class') {
            const val = unescapeEntities(attrs[name]);
            memo ? memo[name] = val : memo = { [name]: val };
        }
        return memo;
    };
    const _attrs = Object.keys(attrs).reduce(addData, null);
    if (_attrs) {
        data.attrs = _attrs;
    }
    const style = parseStyle(attrs);
    if (style) {
        data.style = style;
    }
    const classes = parseClass(attrs);
    if (classes) {
        data.class = classes;
    }
    return data;
}
function parseStyle(attrs) {
    const addStyle = (memo, styleProp) => {
        const res = styleProp.split(':');
        const name = transformName(res[0].trim());
        if (name) {
            const val = res[1].replace('!important', '').trim();
            memo ? memo[name] = val : memo = { [name]: val };
        }
        return memo;
    };
    try {
        return attrs.style.split(';').reduce(addStyle, null);
    }
    catch (e) {
        return null;
    }
}
function parseClass(attrs) {
    const addClass = (memo, className) => {
        className = className.trim();
        if (className) {
            memo ? memo[className] = true : memo = { [className]: true };
        }
        return memo;
    };
    try {
        return attrs.class.split(' ').reduce(addClass, null);
    }
    catch (e) {
        return null;
    }
}
function transformName(name) {
    // Replace -a with A to help camel case style property names.
    name = name.replace(/-(\w)/g, function _replace($1, $2) {
        return $2.toUpperCase();
    });
    // Handle properties that start with a -.
    const firstChar = name.charAt(0).toLowerCase();
    return `${firstChar}${name.substring(1)}`;
}
// Regex for matching HTML entities.
const entityRegex = new RegExp('&[a-z0-9#]+;', 'gi');
// Element for setting innerHTML for transforming entities.
let el = null;
function unescapeEntities(text) {
    // Create the element using the context if it doesn't exist.
    if (!el) {
        el = document.createElement('div');
    }
    return text.replace(entityRegex, (entity) => {
        if (el === null)
            return '';
        el.innerHTML = entity;
        return el.textContent === null ? '' : el.textContent;
    });
}
function recurse(doc, func) {
    let node = doc;
    let parent = null;
    const stack = [];
    const setChild = (n) => {
        const child = n.firstChild;
        if (child !== null) {
            parent = n;
        }
        node = child;
    };
    func(node, parent);
    setChild(node);
    while (true) {
        while (node) {
            stack.push(node);
            func(node, parent);
            setChild(node);
        }
        const _node = stack.pop();
        node = _node ? _node : null;
        if (!stack.length)
            break;
        parent = stack[stack.length - 1];
        if (node) {
            const sibling = node.nextSibling;
            if (sibling == null) {
                parent = stack[stack.length - 1];
            }
            node = sibling;
        }
    }
}
let vdom = null;
const vnodeMap = new Map();
let delimited = false;
function toVNode(node, parent) {
    let current;
    if (parent !== null) {
        current = vnodeMap.get(parent);
    }
    switch (node === null || node === void 0 ? void 0 : node.nodeType) {
        // element
        case 1: {
            if (current === undefined)
                return;
            current.children = current.children ? current.children : [];
            const children = current.children;
            const attributes = node.attributes;
            const attrs = {};
            for (let i = 0; i < attributes.length; i++) {
                const attr = attributes.item(i);
                if (attr) {
                    attrs[attr.name] = attr.value;
                }
            }
            const vn = (0, snabbdom_1.h)(node.nodeName, buildVNodeData(attrs));
            children.push(vn);
            vnodeMap.set(node, vn);
            break;
        }
        // text
        case 3: {
            const text = node.textContent;
            if (text !== null && current !== undefined) {
                current.children = current.children ? current.children : [];
                const children = current.children;
                const lastData = children.length > 0 ? children[children.length - 1] : null;
                if (!delimited && typeof lastData !== 'string' && lastData !== null && lastData.sel === undefined) {
                    lastData.text = lastData.text + text;
                }
                else {
                    children.push((0, snabbdom_1.vnode)(undefined, undefined, undefined, text, undefined));
                }
                delimited = false;
            }
            break;
        }
        case 8: {
            delimited = true;
            break;
        }
        // document
        case 9: {
            vdom = (0, snabbdom_1.vnode)(undefined, undefined, [], undefined, undefined);
            vnodeMap.set(node, vdom);
            break;
        }
        default:
            break;
    }
}
function stripVNode(vnodes) {
    const children = vnodes === null || vnodes === void 0 ? void 0 : vnodes.children;
    if (typeof children === 'undefined')
        return null;
    if (children.length === 1 && typeof children[0] !== 'string')
        return children[0];
    return null;
}
function virtualizeString(html) {
    var _a, _b;
    const parser = new window.DOMParser();
    if (parser === undefined || html === undefined || html === '')
        return null;
    const doc = parser.parseFromString(html, "application/xml");
    if (((_a = doc === null || doc === void 0 ? void 0 : doc.firstChild) === null || _a === void 0 ? void 0 : _a.nodeName) === 'parsererror') {
        const error = `${(_b = doc === null || doc === void 0 ? void 0 : doc.firstChild) === null || _b === void 0 ? void 0 : _b.textContent}`;
        return (0, snabbdom_1.h)('parsererror', [error]);
    }
    delimited = false;
    vdom = null;
    recurse(doc, toVNode);
    if (vdom === null)
        return null;
    return stripVNode(vdom);
}
exports.default = virtualizeString;
//# sourceMappingURL=virtualize.js.map