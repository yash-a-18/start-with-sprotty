"use strict";
/********************************************************************************
 * Copyright (c) 2017-2020 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.ForeignObjectElement = exports.ForeignObjectElementImpl = exports.ShapedPreRenderedElement = exports.ShapedPreRenderedElementImpl = exports.PreRenderedElement = exports.PreRenderedElementImpl = exports.HtmlRoot = exports.HtmlRootImpl = exports.RectangularPort = exports.CircularPort = exports.DiamondNode = exports.RectangularNode = exports.CircularNode = void 0;
const geometry_1 = require("sprotty-protocol/lib/utils/geometry");
const smodel_1 = require("../base/model/smodel");
const model_1 = require("../features/bounds/model");
const model_2 = require("../features/move/model");
const model_3 = require("../features/select/model");
const sgraph_1 = require("../graph/sgraph");
const anchor_1 = require("../features/routing/anchor");
/**
 * A node that is represented by a circle.
 */
class CircularNode extends sgraph_1.SNodeImpl {
    get anchorKind() {
        return anchor_1.ELLIPTIC_ANCHOR_KIND;
    }
}
exports.CircularNode = CircularNode;
/**
 * A node that is represented by a rectangle.
 */
class RectangularNode extends sgraph_1.SNodeImpl {
    get anchorKind() {
        return anchor_1.RECTANGULAR_ANCHOR_KIND;
    }
}
exports.RectangularNode = RectangularNode;
/**
 * A node that is represented by a diamond.
 */
class DiamondNode extends sgraph_1.SNodeImpl {
    get anchorKind() {
        return anchor_1.DIAMOND_ANCHOR_KIND;
    }
}
exports.DiamondNode = DiamondNode;
/**
 * A port that is represented by a circle.
 */
class CircularPort extends sgraph_1.SPortImpl {
    get anchorKind() {
        return anchor_1.ELLIPTIC_ANCHOR_KIND;
    }
}
exports.CircularPort = CircularPort;
/**
 * A port that is represented by a rectangle.
 */
class RectangularPort extends sgraph_1.SPortImpl {
    get anchorKind() {
        return anchor_1.RECTANGULAR_ANCHOR_KIND;
    }
}
exports.RectangularPort = RectangularPort;
/**
 * Root model element class for HTML content. Usually this is rendered with a `div` DOM element.
 */
class HtmlRootImpl extends smodel_1.SModelRootImpl {
    constructor() {
        super(...arguments);
        this.classes = [];
    }
}
exports.HtmlRootImpl = HtmlRootImpl;
/** @deprecated Use `HtmlRootImpl` instead. */
exports.HtmlRoot = HtmlRootImpl;
/**
 * Pre-rendered elements contain HTML or SVG code to be transferred to the DOM. This can be useful to
 * render complex figures or to compute the view on the server instead of the client code.
 */
class PreRenderedElementImpl extends smodel_1.SChildElementImpl {
}
exports.PreRenderedElementImpl = PreRenderedElementImpl;
/** @deprecated Use `PreRenderedElementImpl` instead. */
exports.PreRenderedElement = PreRenderedElementImpl;
/**
 * Same as PreRenderedElement, but with a position and a size.
 */
class ShapedPreRenderedElementImpl extends PreRenderedElementImpl {
    constructor() {
        super(...arguments);
        this.position = geometry_1.Point.ORIGIN;
        this.size = geometry_1.Dimension.EMPTY;
        this.selected = false;
        this.alignment = geometry_1.Point.ORIGIN;
    }
    get bounds() {
        return {
            x: this.position.x,
            y: this.position.y,
            width: this.size.width,
            height: this.size.height
        };
    }
    set bounds(newBounds) {
        this.position = {
            x: newBounds.x,
            y: newBounds.y
        };
        this.size = {
            width: newBounds.width,
            height: newBounds.height
        };
    }
}
exports.ShapedPreRenderedElementImpl = ShapedPreRenderedElementImpl;
ShapedPreRenderedElementImpl.DEFAULT_FEATURES = [model_2.moveFeature, model_1.boundsFeature, model_3.selectFeature, model_1.alignFeature];
/** @deprecated Use `ShapedPreRenderedElementImpl` instead. */
exports.ShapedPreRenderedElement = ShapedPreRenderedElementImpl;
/**
 * A `foreignObject` element to be transferred to the DOM within the SVG.
 *
 * This can be useful to to benefit from e.g. HTML rendering features, such as line wrapping, inside of
 * the SVG diagram.  Note that `foreignObject` is not supported by all browsers and SVG viewers may not
 * support rendering the `foreignObject` content.
 *
 * If no dimensions are specified in the schema element, this element will obtain the dimension of
 * its parent to fill the entire available room. Thus, this element requires specified bounds itself
 * or bounds to be available for its parent.
 */
class ForeignObjectElementImpl extends ShapedPreRenderedElementImpl {
    get bounds() {
        if (geometry_1.Dimension.isValid(this.size)) {
            return {
                x: this.position.x,
                y: this.position.y,
                width: this.size.width,
                height: this.size.height
            };
        }
        else if ((0, model_1.isBoundsAware)(this.parent)) {
            return {
                x: this.position.x,
                y: this.position.y,
                width: this.parent.bounds.width,
                height: this.parent.bounds.height
            };
        }
        return geometry_1.Bounds.EMPTY;
    }
}
exports.ForeignObjectElementImpl = ForeignObjectElementImpl;
/** @deprecated Use `ForeignObjectElementImpl` instead. */
exports.ForeignObjectElement = ForeignObjectElementImpl;
//# sourceMappingURL=model.js.map