/********************************************************************************
 * Copyright (c) 2017-2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
import { Action, ExportSvgAction, RequestModelAction, RequestPopupModelAction } from 'sprotty-protocol/lib/actions';
import { SModelElement, SModelRoot, Viewport } from 'sprotty-protocol/lib/model';
import { IModelLayoutEngine } from 'sprotty-protocol';
import { Bounds } from 'sprotty-protocol/lib/utils/geometry';
import { SModelIndex } from 'sprotty-protocol/lib/utils/model-utils';
import { ILogger } from '../utils/logging';
import { FluentIterable } from '../utils/iterable';
import { ActionHandlerRegistry } from '../base/actions/action-handler';
import { Match } from '../features/update/model-matching';
import { ModelSource, ComputedBoundsApplicator } from './model-source';
export interface IPopupModelProvider {
    getPopupModel(request: RequestPopupModelAction, element?: SModelElement): SModelRoot | undefined;
}
/**
 * A model source that allows to set and modify the model through function calls.
 * This class can be used as a facade over the action-based API of sprotty. It handles
 * actions for bounds calculation and model updates.
 */
export declare class LocalModelSource extends ModelSource {
    protected readonly logger: ILogger;
    protected readonly computedBoundsApplicator: ComputedBoundsApplicator;
    protected popupModelProvider?: IPopupModelProvider;
    protected layoutEngine?: IModelLayoutEngine;
    protected currentRoot: SModelRoot;
    /**
     * The `type` property of the model root is used to determine whether a model update
     * is a change of the previous model or a totally new one.
     */
    protected lastSubmittedModelType: string;
    get model(): SModelRoot;
    set model(root: SModelRoot);
    initialize(registry: ActionHandlerRegistry): void;
    /**
     * Set the model without incremental update.
     */
    setModel(newRoot: SModelRoot): Promise<void>;
    commitModel(newRoot: SModelRoot): Promise<SModelRoot> | SModelRoot;
    /**
     * Apply an incremental update to the model with an animation showing the transition to
     * the new state. If `newRoot` is undefined, the current root is submitted; in that case
     * it is assumed that it has been modified before.
     */
    updateModel(newRoot?: SModelRoot): Promise<void>;
    /**
     * Get the current selection from the model.
     */
    getSelection(): Promise<FluentIterable<SModelElement>>;
    private gatherSelectedElements;
    /**
     * Get the current viewport from the model.
     */
    getViewport(): Promise<Viewport & {
        canvasBounds: Bounds;
    }>;
    /**
     * If client layout is active, run a `RequestBoundsAction` and wait for the resulting
     * `ComputedBoundsAction`, otherwise call `doSubmitModel(â€¦)` directly.
     */
    protected submitModel(newRoot: SModelRoot, update: boolean | Match[], cause?: Action): Promise<void>;
    /**
     * Submit the given model with an `UpdateModelAction` or a `SetModelAction` depending on the
     * `update` argument. If available, the model layout engine is invoked first.
     */
    protected doSubmitModel(newRoot: SModelRoot, update: boolean | Match[], cause?: Action, index?: SModelIndex): Promise<void>;
    /**
     * Modify the current model with an array of matches.
     */
    applyMatches(matches: Match[]): Promise<void>;
    /**
     * Modify the current model by adding new elements.
     */
    addElements(elements: (SModelElement | {
        element: SModelElement;
        parentId: string;
    })[]): Promise<void>;
    /**
     * Modify the current model by removing elements.
     */
    removeElements(elements: (string | {
        elementId: string;
        parentId: string;
    })[]): Promise<void>;
    handle(action: Action): void;
    protected handleRequestModel(action: RequestModelAction): void;
    protected handleRequestPopupModel(action: RequestPopupModelAction): void;
    protected handleExportSvgAction(action: ExportSvgAction): void;
}
//# sourceMappingURL=local-model-source.d.ts.map