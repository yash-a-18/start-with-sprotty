"use strict";
/********************************************************************************
 * Copyright (c) 2017-2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyMatches = exports.ModelMatcher = exports.forEachMatch = void 0;
const smodel_1 = require("../../base/model/smodel");
const sprotty_protocol_1 = require("sprotty-protocol");
function forEachMatch(matchResult, callback) {
    Object.keys(matchResult).forEach(id => callback(id, matchResult[id]));
}
exports.forEachMatch = forEachMatch;
class ModelMatcher {
    match(left, right) {
        const result = {};
        this.matchLeft(left, result);
        this.matchRight(right, result);
        return result;
    }
    matchLeft(element, result, parentId) {
        let match = result[element.id];
        if (match !== undefined) {
            match.left = element;
            match.leftParentId = parentId;
        }
        else {
            match = {
                left: element,
                leftParentId: parentId
            };
            result[element.id] = match;
        }
        if ((0, smodel_1.isParent)(element)) {
            for (const child of element.children) {
                this.matchLeft(child, result, element.id);
            }
        }
    }
    matchRight(element, result, parentId) {
        let match = result[element.id];
        if (match !== undefined) {
            match.right = element;
            match.rightParentId = parentId;
        }
        else {
            match = {
                right: element,
                rightParentId: parentId
            };
            result[element.id] = match;
        }
        if ((0, smodel_1.isParent)(element)) {
            for (const child of element.children) {
                this.matchRight(child, result, element.id);
            }
        }
    }
}
exports.ModelMatcher = ModelMatcher;
function applyMatches(root, matches, index) {
    if (root instanceof smodel_1.SModelRootImpl) {
        index = root.index;
    }
    else if (index === undefined) {
        index = new sprotty_protocol_1.SModelIndex();
        index.add(root);
    }
    for (const match of matches) {
        let newElementInserted = false;
        if (match.left !== undefined && match.leftParentId !== undefined) {
            const parent = index.getById(match.leftParentId);
            if (parent !== undefined && parent.children !== undefined) {
                const i = parent.children.indexOf(match.left);
                if (i >= 0) {
                    if (match.right !== undefined && match.leftParentId === match.rightParentId) {
                        parent.children.splice(i, 1, match.right);
                        newElementInserted = true;
                    }
                    else {
                        parent.children.splice(i, 1);
                    }
                }
                index.remove(match.left);
            }
        }
        if (!newElementInserted && match.right !== undefined && match.rightParentId !== undefined) {
            const parent = index.getById(match.rightParentId);
            if (parent !== undefined) {
                if (parent.children === undefined)
                    parent.children = [];
                parent.children.push(match.right);
            }
        }
    }
}
exports.applyMatches = applyMatches;
//# sourceMappingURL=model-matching.js.map