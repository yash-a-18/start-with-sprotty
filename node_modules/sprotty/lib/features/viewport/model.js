"use strict";
/********************************************************************************
 * Copyright (c) 2017-2023 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.limitViewport = exports.isViewport = exports.viewportFeature = void 0;
const sprotty_protocol_1 = require("sprotty-protocol");
const smodel_1 = require("../../base/model/smodel");
const geometry_1 = require("../../utils/geometry");
exports.viewportFeature = Symbol('viewportFeature');
/**
 * Determine whether the given model element has a viewport.
 */
function isViewport(element) {
    return element instanceof smodel_1.SModelRootImpl
        && element.hasFeature(exports.viewportFeature)
        && 'zoom' in element
        && 'scroll' in element;
}
exports.isViewport = isViewport;
/**
 * Apply limits to the given viewport.
 */
function limitViewport(viewport, canvasBounds, horizontalScrollLimits, verticalScrollLimits, zoomLimits) {
    if (canvasBounds && !sprotty_protocol_1.Dimension.isValid(canvasBounds)) {
        canvasBounds = undefined;
    }
    // Limit the zoom factor
    let zoom = zoomLimits ? (0, geometry_1.limit)(viewport.zoom, zoomLimits) : viewport.zoom;
    if (canvasBounds && horizontalScrollLimits) {
        const minZoom = canvasBounds.width / (horizontalScrollLimits.max - horizontalScrollLimits.min);
        if (zoom < minZoom) {
            zoom = minZoom;
        }
    }
    if (canvasBounds && verticalScrollLimits) {
        const minZoom = canvasBounds.height / (verticalScrollLimits.max - verticalScrollLimits.min);
        if (zoom < minZoom) {
            zoom = minZoom;
        }
    }
    // Limit the horizontal scroll position
    let scrollX;
    if (horizontalScrollLimits) {
        const min = horizontalScrollLimits.min;
        const max = canvasBounds ? horizontalScrollLimits.max - canvasBounds.width / zoom : horizontalScrollLimits.max;
        scrollX = (0, geometry_1.limit)(viewport.scroll.x, { min, max });
    }
    else {
        scrollX = viewport.scroll.x;
    }
    // Limit the vertical scroll position
    let scrollY;
    if (verticalScrollLimits) {
        const min = verticalScrollLimits.min;
        const max = canvasBounds ? verticalScrollLimits.max - canvasBounds.height / zoom : verticalScrollLimits.max;
        scrollY = (0, geometry_1.limit)(viewport.scroll.y, { min, max });
    }
    else {
        scrollY = viewport.scroll.y;
    }
    return { scroll: { x: scrollX, y: scrollY }, zoom };
}
exports.limitViewport = limitViewport;
//# sourceMappingURL=model.js.map