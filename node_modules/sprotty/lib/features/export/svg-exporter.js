"use strict";
/********************************************************************************
 * Copyright (c) 2017-2024 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SvgExporter = exports.ExportSvgAction = void 0;
const inversify_1 = require("inversify");
const geometry_1 = require("sprotty-protocol/lib/utils/geometry");
const action_dispatcher_1 = require("../../base/actions/action-dispatcher");
const types_1 = require("../../base/types");
const model_1 = require("../bounds/model");
var ExportSvgAction;
(function (ExportSvgAction) {
    ExportSvgAction.KIND = 'exportSvg';
    function create(svg, requestId, options) {
        return {
            kind: ExportSvgAction.KIND,
            svg,
            responseId: requestId,
            options
        };
    }
    ExportSvgAction.create = create;
})(ExportSvgAction || (exports.ExportSvgAction = ExportSvgAction = {}));
let SvgExporter = class SvgExporter {
    constructor() {
        this.postprocessors = [];
    }
    export(root, request) {
        var _a;
        if (typeof document !== 'undefined') {
            const hiddenDiv = document.getElementById(this.options.hiddenDiv);
            if (hiddenDiv === null) {
                this.log.warn(this, `Element with id ${this.options.hiddenDiv} not found. Nothing to export.`);
                return;
            }
            const svgElement = hiddenDiv.querySelector('svg');
            if (svgElement === null) {
                this.log.warn(this, `No svg element found in ${this.options.hiddenDiv} div. Nothing to export.`);
                return;
            }
            const svg = this.createSvg(svgElement, root, (_a = request === null || request === void 0 ? void 0 : request.options) !== null && _a !== void 0 ? _a : {}, request);
            this.actionDispatcher.dispatch(ExportSvgAction.create(svg, request ? request.requestId : '', request === null || request === void 0 ? void 0 : request.options));
        }
    }
    createSvg(svgElementOrig, root, options, cause) {
        const serializer = new XMLSerializer();
        const svgCopy = serializer.serializeToString(svgElementOrig);
        const iframe = document.createElement('iframe');
        document.body.appendChild(iframe);
        if (!iframe.contentWindow)
            throw new Error('IFrame has no contentWindow');
        const docCopy = iframe.contentWindow.document;
        docCopy.open();
        docCopy.write(svgCopy);
        docCopy.close();
        const svgElementNew = docCopy.querySelector('svg');
        svgElementNew.removeAttribute('opacity');
        if (!(options === null || options === void 0 ? void 0 : options.skipCopyStyles)) {
            // inline-size copied from sprotty-hidden svg shrinks the svg so it is not visible.
            this.copyStyles(svgElementOrig, svgElementNew, ['width', 'height', 'opacity', 'inline-size']);
        }
        svgElementNew.setAttribute('version', '1.1');
        const bounds = this.getBounds(root, docCopy);
        svgElementNew.setAttribute('viewBox', `${bounds.x} ${bounds.y} ${bounds.width} ${bounds.height}`);
        svgElementNew.setAttribute('width', `${bounds.width}`);
        svgElementNew.setAttribute('height', `${bounds.height}`);
        this.postprocessors.forEach(postprocessor => {
            postprocessor.postUpdate(svgElementNew, cause);
        });
        const svgCode = serializer.serializeToString(svgElementNew);
        document.body.removeChild(iframe);
        return svgCode;
    }
    copyStyles(source, target, skippedProperties) {
        const sourceStyle = getComputedStyle(source);
        const targetStyle = getComputedStyle(target);
        let diffStyle = '';
        for (let i = 0; i < sourceStyle.length; i++) {
            const key = sourceStyle[i];
            if (skippedProperties.indexOf(key) === -1) {
                const value = sourceStyle.getPropertyValue(key);
                if (targetStyle.getPropertyValue(key) !== value) {
                    diffStyle += key + ':' + value + ';';
                }
            }
        }
        if (diffStyle !== '')
            target.setAttribute('style', diffStyle);
        // IE doesn't return anything on source.children
        for (let i = 0; i < source.childNodes.length; ++i) {
            const sourceChild = source.childNodes[i];
            const targetChild = target.childNodes[i];
            if (sourceChild instanceof Element)
                this.copyStyles(sourceChild, targetChild, []);
        }
    }
    getBounds(root, document) {
        const svgElement = document.querySelector('svg');
        if (svgElement) {
            return svgElement.getBBox();
        }
        const allBounds = [geometry_1.Bounds.EMPTY];
        root.children.forEach(element => {
            if ((0, model_1.isBoundsAware)(element)) {
                allBounds.push(element.bounds);
            }
        });
        return allBounds.reduce((one, two) => geometry_1.Bounds.combine(one, two));
    }
};
exports.SvgExporter = SvgExporter;
__decorate([
    (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
    __metadata("design:type", Object)
], SvgExporter.prototype, "options", void 0);
__decorate([
    (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
    __metadata("design:type", action_dispatcher_1.ActionDispatcher)
], SvgExporter.prototype, "actionDispatcher", void 0);
__decorate([
    (0, inversify_1.inject)(types_1.TYPES.ILogger),
    __metadata("design:type", Object)
], SvgExporter.prototype, "log", void 0);
__decorate([
    (0, inversify_1.multiInject)(types_1.TYPES.ISvgExportPostprocessor),
    (0, inversify_1.optional)(),
    __metadata("design:type", Array)
], SvgExporter.prototype, "postprocessors", void 0);
exports.SvgExporter = SvgExporter = __decorate([
    (0, inversify_1.injectable)()
], SvgExporter);
//# sourceMappingURL=svg-exporter.js.map