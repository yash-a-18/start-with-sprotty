"use strict";
/********************************************************************************
 * Copyright (c) 2019 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ManhattanRectangularAnchor_1, ManhattanDiamondAnchor_1, ManhattanEllipticAnchor_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManhattanEllipticAnchor = exports.ManhattanDiamondAnchor = exports.ManhattanRectangularAnchor = void 0;
const geometry_1 = require("sprotty-protocol/lib/utils/geometry");
const geometry_2 = require("../../utils/geometry");
const anchor_1 = require("./anchor");
const manhattan_edge_router_1 = require("./manhattan-edge-router");
const inversify_1 = require("inversify");
let ManhattanRectangularAnchor = ManhattanRectangularAnchor_1 = class ManhattanRectangularAnchor {
    get kind() {
        return ManhattanRectangularAnchor_1.KIND;
    }
    getAnchor(connectable, refPoint, offset) {
        const b = connectable.bounds;
        if (b.width <= 0 || b.height <= 0) {
            return b;
        }
        const bounds = {
            x: b.x - offset,
            y: b.y - offset,
            width: b.width + 2 * offset,
            height: b.height + 2 * offset
        };
        if (refPoint.x >= bounds.x && bounds.x + bounds.width >= refPoint.x) {
            if (refPoint.y < bounds.y + 0.5 * bounds.height)
                return { x: refPoint.x, y: bounds.y };
            else
                return { x: refPoint.x, y: bounds.y + bounds.height };
        }
        if (refPoint.y >= bounds.y && bounds.y + bounds.height >= refPoint.y) {
            if (refPoint.x < bounds.x + 0.5 * bounds.width)
                return { x: bounds.x, y: refPoint.y };
            else
                return { x: bounds.x + bounds.width, y: refPoint.y };
        }
        return geometry_1.Bounds.center(bounds);
    }
};
exports.ManhattanRectangularAnchor = ManhattanRectangularAnchor;
ManhattanRectangularAnchor.KIND = manhattan_edge_router_1.ManhattanEdgeRouter.KIND + ':' + anchor_1.RECTANGULAR_ANCHOR_KIND;
exports.ManhattanRectangularAnchor = ManhattanRectangularAnchor = ManhattanRectangularAnchor_1 = __decorate([
    (0, inversify_1.injectable)()
], ManhattanRectangularAnchor);
let ManhattanDiamondAnchor = ManhattanDiamondAnchor_1 = class ManhattanDiamondAnchor {
    get kind() {
        return ManhattanDiamondAnchor_1.KIND;
    }
    getAnchor(connectable, refPoint, offset = 0) {
        const b = connectable.bounds;
        if (b.width <= 0 || b.height <= 0) {
            return b;
        }
        const bounds = {
            x: b.x - offset,
            y: b.y - offset,
            width: b.width + 2 * offset,
            height: b.height + 2 * offset
        };
        const c = geometry_1.Bounds.center(bounds);
        let outline = undefined;
        let refLine = undefined;
        if (refPoint.x >= bounds.x && refPoint.x <= bounds.x + bounds.width) {
            if (bounds.x + 0.5 * bounds.width >= refPoint.x) {
                refLine = new geometry_2.PointToPointLine(refPoint, { x: refPoint.x, y: c.y });
                if (refPoint.y < c.y)
                    outline = new geometry_2.PointToPointLine({ x: bounds.x, y: c.y }, { x: c.x, y: bounds.y });
                else
                    outline = new geometry_2.PointToPointLine({ x: bounds.x, y: c.y }, { x: c.x, y: bounds.y + bounds.height });
            }
            else {
                refLine = new geometry_2.PointToPointLine(refPoint, { x: refPoint.x, y: c.y });
                if (refPoint.y < c.y)
                    outline = new geometry_2.PointToPointLine({ x: bounds.x + bounds.width, y: c.y }, { x: c.x, y: bounds.y });
                else
                    outline = new geometry_2.PointToPointLine({ x: bounds.x + bounds.width, y: c.y }, { x: c.x, y: bounds.y + bounds.height });
            }
        }
        else if (refPoint.y >= bounds.y && refPoint.y <= bounds.y + bounds.height) {
            if (bounds.y + 0.5 * bounds.height >= refPoint.y) {
                refLine = new geometry_2.PointToPointLine(refPoint, { x: c.x, y: refPoint.y });
                if (refPoint.x < c.x)
                    outline = new geometry_2.PointToPointLine({ x: bounds.x, y: c.y }, { x: c.x, y: bounds.y });
                else
                    outline = new geometry_2.PointToPointLine({ x: bounds.x + bounds.width, y: c.y }, { x: c.x, y: bounds.y });
            }
            else {
                refLine = new geometry_2.PointToPointLine(refPoint, { x: c.x, y: refPoint.y });
                if (refPoint.x < c.x)
                    outline = new geometry_2.PointToPointLine({ x: bounds.x, y: c.y }, { x: c.x, y: bounds.y + bounds.height });
                else
                    outline = new geometry_2.PointToPointLine({ x: bounds.x + bounds.width, y: c.y }, { x: c.x, y: bounds.y + bounds.height });
            }
        }
        if (!!refLine && !!outline)
            return (0, geometry_2.intersection)(outline, refLine);
        else
            return c;
    }
};
exports.ManhattanDiamondAnchor = ManhattanDiamondAnchor;
ManhattanDiamondAnchor.KIND = manhattan_edge_router_1.ManhattanEdgeRouter.KIND + ':' + anchor_1.DIAMOND_ANCHOR_KIND;
exports.ManhattanDiamondAnchor = ManhattanDiamondAnchor = ManhattanDiamondAnchor_1 = __decorate([
    (0, inversify_1.injectable)()
], ManhattanDiamondAnchor);
let ManhattanEllipticAnchor = ManhattanEllipticAnchor_1 = class ManhattanEllipticAnchor {
    get kind() {
        return ManhattanEllipticAnchor_1.KIND;
    }
    getAnchor(connectable, refPoint, offset = 0) {
        const b = connectable.bounds;
        if (b.width <= 0 || b.height <= 0) {
            return b;
        }
        const bounds = {
            x: b.x - offset,
            y: b.y - offset,
            width: b.width + 2 * offset,
            height: b.height + 2 * offset
        };
        const c = geometry_1.Bounds.center(bounds);
        const refRelative = geometry_1.Point.subtract(refPoint, c);
        let x = c.x;
        let y = c.y;
        if (refPoint.x >= bounds.x && bounds.x + bounds.width >= refPoint.x) {
            x += refRelative.x;
            const dy = 0.5 * bounds.height * Math.sqrt(1 - (refRelative.x * refRelative.x) / (0.25 * bounds.width * bounds.width));
            if (refRelative.y < 0)
                y -= dy;
            else
                y += dy;
        }
        else if (refPoint.y >= bounds.y && bounds.y + bounds.height >= refPoint.y) {
            y += refRelative.y;
            const dx = 0.5 * bounds.width * Math.sqrt(1 - (refRelative.y * refRelative.y) / (0.25 * bounds.height * bounds.height));
            if (refRelative.x < 0)
                x -= dx;
            else
                x += dx;
        }
        return { x, y };
    }
};
exports.ManhattanEllipticAnchor = ManhattanEllipticAnchor;
ManhattanEllipticAnchor.KIND = manhattan_edge_router_1.ManhattanEdgeRouter.KIND + ':' + anchor_1.ELLIPTIC_ANCHOR_KIND;
exports.ManhattanEllipticAnchor = ManhattanEllipticAnchor = ManhattanEllipticAnchor_1 = __decorate([
    (0, inversify_1.injectable)()
], ManhattanEllipticAnchor);
//# sourceMappingURL=manhattan-anchors.js.map