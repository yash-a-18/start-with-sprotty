/********************************************************************************
 * Copyright (c) 2019-2020 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
import { Bounds, Point } from "sprotty-protocol/lib/utils/geometry";
import { SParentElementImpl } from "../../base/model/smodel";
import { ResolvedHandleMove } from "../move/move";
import { RoutingHandleKind, SRoutingHandleImpl } from "./model";
import { AnchorComputerRegistry, IAnchorComputer } from "./anchor";
import { SConnectableElementImpl, SRoutableElementImpl } from "./model";
import { EdgeSnapshot, IEdgeRouter, RoutedPoint } from "./routing";
export interface LinearRouteOptions {
    minimalPointDistance: number;
    standardDistance: number;
    selfEdgeOffset: number;
}
export declare enum Side {
    RIGHT = 0,
    LEFT = 1,
    TOP = 2,
    BOTTOM = 3
}
export declare class DefaultAnchors {
    readonly element: SConnectableElementImpl;
    readonly kind: 'source' | 'target';
    readonly bounds: Bounds;
    readonly left: RoutedPoint;
    readonly right: RoutedPoint;
    readonly top: RoutedPoint;
    readonly bottom: RoutedPoint;
    constructor(element: SConnectableElementImpl, edgeParent: SParentElementImpl, kind: 'source' | 'target');
    get(side: Side): RoutedPoint;
    getNearestSide(point: Point): Side;
}
export declare abstract class AbstractEdgeRouter implements IEdgeRouter {
    anchorRegistry: AnchorComputerRegistry;
    abstract get kind(): string;
    abstract route(edge: SRoutableElementImpl): RoutedPoint[];
    abstract createRoutingHandles(edge: SRoutableElementImpl): void;
    protected abstract getOptions(edge: SRoutableElementImpl): LinearRouteOptions;
    findOrthogonalIntersection(edge: SRoutableElementImpl, point: Point): {
        point: Point;
        derivative: Point;
    };
    pointAt(edge: SRoutableElementImpl, t: number): Point | undefined;
    derivativeAt(edge: SRoutableElementImpl, t: number): Point | undefined;
    protected calculateSegment(edge: SRoutableElementImpl, t: number): {
        segmentStart: Point;
        segmentEnd: Point;
        lambda: number;
    } | undefined;
    protected addHandle(edge: SRoutableElementImpl, kind: RoutingHandleKind, type: string, routingPointIndex: number): SRoutingHandleImpl;
    getHandlePosition(edge: SRoutableElementImpl, route: RoutedPoint[], handle: SRoutingHandleImpl): Point | undefined;
    protected abstract getInnerHandlePosition(edge: SRoutableElementImpl, route: RoutedPoint[], handle: SRoutingHandleImpl): Point | undefined;
    protected findRouteSegment(edge: SRoutableElementImpl, route: RoutedPoint[], handleIndex: number): {
        start?: Point;
        end?: Point;
    };
    getTranslatedAnchor(connectable: SConnectableElementImpl, refPoint: Point, refContainer: SParentElementImpl, edge: SRoutableElementImpl, anchorCorrection?: number): Point;
    protected getAnchorComputer(connectable: SConnectableElementImpl): IAnchorComputer;
    applyHandleMoves(edge: SRoutableElementImpl, moves: ResolvedHandleMove[]): void;
    protected abstract applyInnerHandleMoves(edge: SRoutableElementImpl, moves: ResolvedHandleMove[]): void;
    cleanupRoutingPoints(edge: SRoutableElementImpl, routingPoints: Point[], updateHandles: boolean, addRoutingPoints: boolean): void;
    protected resetRoutingPointsOnReconnect(edge: SRoutableElementImpl, routingPoints: Point[], updateHandles: boolean, sourceAnchors: DefaultAnchors, targetAnchors: DefaultAnchors): boolean;
    applyReconnect(edge: SRoutableElementImpl, newSourceId?: string, newTargetId?: string): void;
    takeSnapshot(edge: SRoutableElementImpl): EdgeSnapshot;
    applySnapshot(edge: SRoutableElementImpl, snapshot: EdgeSnapshot): void;
    protected calculateDefaultCorners(edge: SRoutableElementImpl, sourceAnchors: DefaultAnchors, targetAnchors: DefaultAnchors, options: LinearRouteOptions): Point[];
    protected getSelfEdgeIndex(edge: SRoutableElementImpl): number;
    protected commitRoute(edge: SRoutableElementImpl, routedPoints: RoutedPoint[]): void;
}
//# sourceMappingURL=abstract-edge-router.d.ts.map