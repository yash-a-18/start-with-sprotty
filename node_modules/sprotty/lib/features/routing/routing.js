"use strict";
/********************************************************************************
 * Copyright (c) 2018-2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EdgeRouting = exports.EdgeRouterRegistry = void 0;
const inversify_1 = require("inversify");
const smodel_1 = require("../../base/model/smodel");
const types_1 = require("../../base/types");
const view_1 = require("../../base/views/view");
const registry_1 = require("../../utils/registry");
const model_1 = require("./model");
const polyline_edge_router_1 = require("./polyline-edge-router");
function isMultipleEdgesRouter(router) {
    return router.routeAll !== undefined;
}
let EdgeRouterRegistry = class EdgeRouterRegistry extends registry_1.InstanceRegistry {
    constructor(edgeRouters) {
        super();
        edgeRouters.forEach(router => this.register(router.kind, router));
    }
    get defaultKind() {
        return polyline_edge_router_1.PolylineEdgeRouter.KIND;
    }
    get(kind) {
        return super.get(kind || this.defaultKind);
    }
    /**
     * Computes the routes of all edges contained by the specified `parent`.
     * After all routes are available, it'll apply the registered `EdgeRoutePostProcessors`.
     * @param parent the parent to traverse for edges
     * @returns the routes of all edges that are children of `parent`
     */
    routeAllChildren(parent) {
        const routing = this.doRouteAllChildren(parent);
        for (const postProcessor of this.postProcessors) {
            postProcessor.apply(routing, parent);
        }
        return routing;
    }
    /**
     * Recursively traverses the children of `parent`, collects children grouped by router kind,
     * and then routes them either.
     * @param parent the parent to traverse for edges
     * @returns the routes of all edges that are children of `parent`
     */
    doRouteAllChildren(parent) {
        const routing = new EdgeRouting();
        const routersEdges = new Map();
        const elementsToProcess = [parent];
        while (elementsToProcess.length > 0) {
            const element = elementsToProcess.shift();
            for (const child of element.children) {
                if (child instanceof model_1.SRoutableElementImpl) {
                    const routerKind = child.routerKind || this.defaultKind;
                    if (routersEdges.has(routerKind)) {
                        routersEdges.get(routerKind).push(child);
                    }
                    else {
                        routersEdges.set(routerKind, [child]);
                    }
                }
                if (child instanceof smodel_1.SParentElementImpl) {
                    elementsToProcess.push(child);
                }
            }
        }
        routersEdges.forEach((edges, routerKind) => {
            const childRouter = this.get(routerKind);
            if (isMultipleEdgesRouter(childRouter)) {
                routing.setAll(childRouter.routeAll(edges, parent));
            }
            else {
                for (const edge of edges) {
                    routing.set(edge.id, this.route(edge));
                }
            }
        });
        return routing;
    }
    /**
     * Computes or obtains the route of a single edge.
     * @param edge the edge to be routed
     * @param args arguments that may contain an `EdgeRouting` already
     * @returns the route of the specified `edge`
     */
    route(edge, args) {
        const edgeRouting = (0, view_1.findArgValue)(args, 'edgeRouting');
        if (edgeRouting) {
            const route = edgeRouting.get(edge.id);
            if (route) {
                return route;
            }
        }
        const router = this.get(edge.routerKind);
        return router.route(edge);
    }
};
exports.EdgeRouterRegistry = EdgeRouterRegistry;
__decorate([
    (0, inversify_1.multiInject)(types_1.TYPES.IEdgeRoutePostprocessor),
    (0, inversify_1.optional)(),
    __metadata("design:type", Array)
], EdgeRouterRegistry.prototype, "postProcessors", void 0);
exports.EdgeRouterRegistry = EdgeRouterRegistry = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.multiInject)(types_1.TYPES.IEdgeRouter)),
    __metadata("design:paramtypes", [Array])
], EdgeRouterRegistry);
/**
 * Map of edges and their computed routes.
 */
class EdgeRouting {
    constructor() {
        this.routesMap = new Map();
    }
    set(routableId, route) {
        this.routesMap.set(routableId, route);
    }
    setAll(otherRoutes) {
        otherRoutes.routes.forEach((route, routableId) => this.set(routableId, route));
    }
    get(routableId) {
        return this.routesMap.get(routableId);
    }
    get routes() {
        return this.routesMap;
    }
}
exports.EdgeRouting = EdgeRouting;
//# sourceMappingURL=routing.js.map