/********************************************************************************
 * Copyright (c) 2019 Rowan Winsemius and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
import TinyQueue from "tinyqueue";
import { Point } from "sprotty-protocol/lib/utils/geometry";
import { Intersection } from "./intersection-finder";
import { RoutedPoint } from "../routing/routing";
/**
 * Add the specified `route` to the event `queue` from left to right.
 * @param routeId id of the route.
 * @param route the route as array of points.
 * @param queue the queue to add the route to.
 */
export declare function addRoute(routeId: string, route: RoutedPoint[], queue: TinyQueue<SweepEvent>): void;
/**
 * Returns which of the two events is left.
 * This is used to classify the endpoints of a segment when generating the
 * event queue.
 */
export declare function checkWhichEventIsLeft(e1: SweepEvent, e2: SweepEvent): 1 | -1;
/**
 * An event -- or with other words a start or end point of a segment -- in the context
 * of the event queue for the sweep.
 *
 * Stores the original Sprotty `edgeId` and the segment index of this segment in the edge
 * to keep track of which edge and segment this event originated from.
 */
export declare class SweepEvent {
    readonly edgeId: string;
    readonly point: Point;
    readonly segmentIndex: number;
    otherEvent: SweepEvent;
    isLeftEndpoint: boolean;
    constructor(edgeId: string, point: Point, segmentIndex: number);
}
/**
 * A line segment consists of a start and a stop event.
 */
export declare class Segment {
    readonly leftSweepEvent: SweepEvent;
    readonly rightSweepEvent: SweepEvent;
    constructor(event: SweepEvent);
}
/**
 * Performs the main sweep algorithm on the specified event queue.
 *
 * An empty priority queue is created to store segments encountered.
 * An item is removed from the priority queue if the vertex is the left endpoint
 * of a segment, we test it against every other segment in the segment queue for
 * intersections with any intersection recorded. We then add the vertex (and it's
 * associated right endpoint) to the segment queue.
 * If we encounter a right endpoint we remove the first item from the segment queue.
 *
 * Each pair of segments are only tested once. And only segments that overlap on the
 * x plane are tested against each other.
 *
 * @param eventQueue the event queue.
 * @returns the identified intersections.
 */
export declare function runSweep(eventQueue: TinyQueue<SweepEvent>): Intersection[];
/**
 * Specifies which of the two specified segments has a right endpoint first.
 * Used as a comparator to sort the event queue.
 */
export declare function checkWhichSegmentHasRightEndpointFirst(seg1: Segment, seg2: Segment): 1 | -1;
export declare function getSegmentIndex(segment: Segment): number;
/**
 * Tests whether two segments intersect and returns the intersection point if existing.
 */
export declare function intersectionOfSegments(seg1: Segment, seg2: Segment): Point | undefined;
//# sourceMappingURL=sweepline.d.ts.map