/********************************************************************************
 * Copyright (c) 2017-2020 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
import { VNode } from 'snabbdom';
import { Locateable } from 'sprotty-protocol/lib/model';
import { Point } from 'sprotty-protocol/lib/utils/geometry';
import { Action, MoveAction } from 'sprotty-protocol/lib/actions';
import { Animation } from '../../base/animations/animation';
import { CommandExecutionContext, ICommand, MergeableCommand, CommandReturn, IStoppableCommand } from '../../base/commands/command';
import { SChildElementImpl, SModelElementImpl, SModelRootImpl } from '../../base/model/smodel';
import { MouseListener } from '../../base/views/mouse-tool';
import { IVNodePostprocessor } from '../../base/views/vnode-postprocessor';
import { CreatingOnDrag } from '../edit/create-on-drag';
import { SRoutableElementImpl, SRoutingHandleImpl } from '../routing/model';
import { EdgeMemento, EdgeRouterRegistry, RoutedPoint } from '../routing/routing';
import { ISnapper } from './snap';
export interface ElementMove {
    elementId: string;
    elementType?: string;
    fromPosition?: Point;
    toPosition: Point;
}
export interface ResolvedElementMove {
    element: SModelElementImpl & Locateable;
    fromPosition: Point;
    toPosition: Point;
}
export interface ResolvedHandleMove {
    handle: SRoutingHandleImpl;
    fromPosition: Point;
    toPosition: Point;
}
export declare class MoveCommand extends MergeableCommand implements IStoppableCommand {
    protected readonly action: MoveAction;
    static readonly KIND = "move";
    edgeRouterRegistry?: EdgeRouterRegistry;
    protected resolvedMoves: Map<string, ResolvedElementMove>;
    protected edgeMementi: EdgeMemento[];
    protected animation: Animation | undefined;
    stoppableCommandKey: string;
    constructor(action: MoveAction);
    stopExecution(): void;
    execute(context: CommandExecutionContext): CommandReturn;
    protected resolveHandleMove(handle: SRoutingHandleImpl, edge: SRoutableElementImpl, move: ElementMove): ResolvedHandleMove | undefined;
    protected resolveElementMove(element: SModelElementImpl & Locateable, move: ElementMove): ResolvedElementMove | undefined;
    protected doMove(edge2move: Map<SRoutableElementImpl, ResolvedHandleMove[]>, attachedEdgeShifts: Map<SRoutableElementImpl, Point>): void;
    protected isChildOfMovedElements(el: SChildElementImpl): boolean;
    protected isAttachedEdge(edge: SRoutableElementImpl): boolean;
    protected undoMove(): void;
    undo(context: CommandExecutionContext): Promise<SModelRootImpl>;
    redo(context: CommandExecutionContext): Promise<SModelRootImpl>;
    merge(other: ICommand, context: CommandExecutionContext): boolean;
}
export declare class MoveAnimation extends Animation {
    protected model: SModelRootImpl;
    elementMoves: Map<string, ResolvedElementMove>;
    protected reverse: boolean;
    constructor(model: SModelRootImpl, elementMoves: Map<string, ResolvedElementMove>, context: CommandExecutionContext, reverse?: boolean);
    tween(t: number): SModelRootImpl;
}
interface ExpandedEdgeMorph {
    startExpandedRoute: Point[];
    endExpandedRoute: Point[];
    memento: EdgeMemento;
}
export declare class MorphEdgesAnimation extends Animation {
    protected model: SModelRootImpl;
    protected reverse: boolean;
    protected expanded: ExpandedEdgeMorph[];
    constructor(model: SModelRootImpl, originalMementi: EdgeMemento[], context: CommandExecutionContext, reverse?: boolean);
    protected midPoint(edgeMemento: EdgeMemento): Point;
    start(): Promise<SModelRootImpl>;
    tween(t: number): SModelRootImpl;
    protected growToSize(route: RoutedPoint[], targetSize: number): Point[];
}
export declare class MoveMouseListener extends MouseListener {
    edgeRouterRegistry?: EdgeRouterRegistry;
    snapper?: ISnapper;
    hasDragged: boolean;
    startDragPosition: Point | undefined;
    elementId2startPos: Map<string, Point>;
    mouseDown(target: SModelElementImpl, event: MouseEvent): (Action | Promise<Action>)[];
    protected startCreatingOnDrag(target: CreatingOnDrag, event: MouseEvent): (Action | Promise<Action>)[];
    protected activateRoutingHandle(target: SRoutingHandleImpl, event: MouseEvent): (Action | Promise<Action>)[];
    mouseMove(target: SModelElementImpl, event: MouseEvent): Action[];
    protected collectStartPositions(root: SModelRootImpl): void;
    protected isChildOfSelected(selectedElements: Set<SModelElementImpl>, element: SModelElementImpl): boolean;
    protected getElementMoves(target: SModelElementImpl, event: MouseEvent, isFinished: boolean): MoveAction | undefined;
    protected createElementMove(element: SModelElementImpl, startPosition: Point, delta: Point, event: MouseEvent): ElementMove | undefined;
    protected snap(position: Point, element: SModelElementImpl, isSnap: boolean): Point;
    protected getHandlePosition(handle: SRoutingHandleImpl): Point | undefined;
    mouseEnter(target: SModelElementImpl, event: MouseEvent): Action[];
    mouseUp(target: SModelElementImpl, event: MouseEvent): (Action | Promise<Action>)[];
    protected deactivateRoutingHandle(element: SRoutingHandleImpl, target: SModelElementImpl, event: MouseEvent): Action[];
    protected deleteEdgeInProgress(edgeInProgress: SChildElementImpl): Action;
    decorate(vnode: VNode, element: SModelElementImpl): VNode;
}
export declare class LocationPostprocessor implements IVNodePostprocessor {
    decorate(vnode: VNode, element: SModelElementImpl): VNode;
    postUpdate(): void;
}
export {};
//# sourceMappingURL=move.d.ts.map