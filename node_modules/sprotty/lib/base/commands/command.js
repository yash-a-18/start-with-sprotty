"use strict";
/********************************************************************************
 * Copyright (c) 2017-2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResetCommand = exports.SystemCommand = exports.PopupCommand = exports.HiddenCommand = exports.MergeableCommand = exports.Command = exports.isStoppableCommand = void 0;
require("reflect-metadata");
const inversify_1 = require("inversify");
const sprotty_protocol_1 = require("sprotty-protocol");
function isStoppableCommand(command) {
    return command && (0, sprotty_protocol_1.hasOwnProperty)(command, 'stoppableCommandKey') && 'stopExecution' in command && typeof command.stopExecution === 'function';
}
exports.isStoppableCommand = isStoppableCommand;
/**
 * Base class for all commands.
 *
 * Command instances are created via dependency injection and should take
 * the respective action as an injected constructor parameter. They must
 * also define a static <code>KIND</code> which is used to map an
 * <code>Action#kind</code>.
 *
 * <pre>
 * export class MyCommand extends Command {
 *   static KIND = 'MyCommand'
 *   constructor(@inject(TYPES.Action) action: MyAction) {
 *   ...
 * }
 * @inject(TYPES.Action)
 * </pre>
 */
let Command = class Command {
};
exports.Command = Command;
exports.Command = Command = __decorate([
    (0, inversify_1.injectable)()
], Command);
/**
 * A mergeable command can accumulate subsequent commands of the same kind.
 *
 * For example, multiple subsequent move commands can be merged to yield a
 * single command, such that undo will roll them back altogether. Otherwise
 * the user would have to push CTRL-Z for each mouse move element that
 * resuted in a command.
 */
let MergeableCommand = class MergeableCommand extends Command {
    /**
     * Tries to merge the given command with this.
     *
     * @param command
     * @param context
     */
    merge(command, context) {
        return false;
    }
};
exports.MergeableCommand = MergeableCommand;
exports.MergeableCommand = MergeableCommand = __decorate([
    (0, inversify_1.injectable)()
], MergeableCommand);
/**
 * A hidden command is used to trigger the rendering of a model on a
 * hidden canvas.
 *
 * Some graphical elements are styled using CSS, others have bounds that
 * require to layout their children before being computed. In such cases
 * we cannot tell about the size of elements without acutally rendering
 * the DOM. We render them to an invisible canvas. This can be achieved
 * using hidden commands.
 *
 * Hidden commands do not change the model directly, and are as such
 * neither undoable nor redoable. The command stack does not push them on
 * any stack and forwards the resulting model to the invisible viewer.
 */
let HiddenCommand = class HiddenCommand extends Command {
    undo(context) {
        context.logger.error(this, 'Cannot undo a hidden command');
        return context.root;
    }
    redo(context) {
        context.logger.error(this, 'Cannot redo a hidden command');
        return context.root;
    }
};
exports.HiddenCommand = HiddenCommand;
exports.HiddenCommand = HiddenCommand = __decorate([
    (0, inversify_1.injectable)()
], HiddenCommand);
let PopupCommand = class PopupCommand extends Command {
};
exports.PopupCommand = PopupCommand;
exports.PopupCommand = PopupCommand = __decorate([
    (0, inversify_1.injectable)()
], PopupCommand);
/**
 * A system command is triggered by the system, e.g. in order to update bounds
 * in the model with data fetched from the DOM.
 *
 * As it is automatically triggered it should not count as a single command in
 * undo/redo operations. Into the bargain, such an automatic command could occur
 * after an undo and as such make the next redo command invalid because it is
 * based on a model state that has changed. The command stack handles system
 * commands in a special way to overcome these issues.
 */
let SystemCommand = class SystemCommand extends Command {
};
exports.SystemCommand = SystemCommand;
exports.SystemCommand = SystemCommand = __decorate([
    (0, inversify_1.injectable)()
], SystemCommand);
/**
 * A reset command deletes all undo/redo stacks and cannot be undone.
 *
 * It marks a point of no return.
 */
let ResetCommand = class ResetCommand extends Command {
};
exports.ResetCommand = ResetCommand;
exports.ResetCommand = ResetCommand = __decorate([
    (0, inversify_1.injectable)()
], ResetCommand);
//# sourceMappingURL=command.js.map