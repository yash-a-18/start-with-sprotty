"use strict";
/********************************************************************************
 * Copyright (c) 2017-2024 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var MissingView_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MissingView = exports.EmptyView = exports.configureView = exports.overrideModelElement = exports.configureModelElement = exports.ViewRegistry = exports.findArgValue = void 0;
/** @jsx svg */
const jsx_1 = require("../../lib/jsx");
const inversify_1 = require("inversify");
const types_1 = require("../types");
const registry_1 = require("../../utils/registry");
const inversify_2 = require("../../utils/inversify");
const smodel_factory_1 = require("../model/smodel-factory");
const smodel_utils_1 = require("../model/smodel-utils");
const sprotty_protocol_1 = require("sprotty-protocol");
/**
 * Searches for the property specified in `key` in the specified `args`,
 * including its direct or indirect `IRenderingArgs#parentArgs`.
 *
 * @param arg the rendering arguments.
 * @param key the key to search for.
 * @returns the found value or `undefined.
 */
function findArgValue(arg, key) {
    while (arg !== undefined && !(key in arg) && arg.parentArgs) {
        arg = arg.parentArgs;
    }
    return arg ? arg[key] : undefined;
}
exports.findArgValue = findArgValue;
/**
 * Allows to look up the IView for a given SModelElement based on its type.
 */
let ViewRegistry = class ViewRegistry extends registry_1.InstanceRegistry {
    constructor(registrations) {
        super();
        this.registerDefaults();
        registrations.forEach(registration => {
            if (registration.isOverride) {
                this.override(registration.type, registration.factory());
            }
            else {
                this.register(registration.type, registration.factory());
            }
        });
    }
    registerDefaults() {
        this.register(smodel_factory_1.EMPTY_ROOT.type, new EmptyView());
    }
    missing(key) {
        this.logger.warn(this, `no registered view for type '${key}', please configure a view in the ContainerModule`);
        return new MissingView();
    }
};
exports.ViewRegistry = ViewRegistry;
__decorate([
    (0, inversify_1.inject)(types_1.TYPES.ILogger),
    __metadata("design:type", Object)
], ViewRegistry.prototype, "logger", void 0);
exports.ViewRegistry = ViewRegistry = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.multiInject)(types_1.TYPES.ViewRegistration)),
    __param(0, (0, inversify_1.optional)()),
    __metadata("design:paramtypes", [Array])
], ViewRegistry);
/**
 * Combines `registerModelElement` and `configureView`.
 */
function configureModelElement(context, type, modelConstr, viewConstr, features) {
    (0, smodel_utils_1.registerModelElement)(context, type, modelConstr, features);
    configureView(context, type, viewConstr);
}
exports.configureModelElement = configureModelElement;
function overrideModelElement(context, type, modelConstr, viewConstr, features) {
    (0, smodel_utils_1.registerModelElement)(context, type, modelConstr, features, true);
    configureView(context, type, viewConstr, true);
}
exports.overrideModelElement = overrideModelElement;
/**
 * Utility function to register a view for a model element type.
 */
function configureView(context, type, constr, isOverride) {
    if (typeof constr === 'function') {
        if (!(0, inversify_2.isInjectable)(constr)) {
            throw new Error(`Views should be @injectable: ${constr.name}`);
        }
        if (!context.isBound(constr)) {
            context.bind(constr).toSelf();
        }
    }
    context.bind(types_1.TYPES.ViewRegistration).toDynamicValue(ctx => ({
        type,
        factory: () => ctx.container.get(constr),
        isOverride
    }));
}
exports.configureView = configureView;
/**
 * This view is used when the model is the EMPTY_ROOT.
 */
let EmptyView = class EmptyView {
    render(model, context) {
        return (0, jsx_1.svg)("svg", { "class-sprotty-empty": true });
    }
};
exports.EmptyView = EmptyView;
exports.EmptyView = EmptyView = __decorate([
    (0, inversify_1.injectable)()
], EmptyView);
/**
 * This view is used when no view has been registered for a model element type.
 */
let MissingView = MissingView_1 = class MissingView {
    render(model, context) {
        const position = model.position || this.getPostion(model.type);
        return (0, jsx_1.svg)("text", { "class-sprotty-missing": true, x: position.x, y: position.y },
            "missing \"",
            model.type,
            "\" view");
    }
    getPostion(type) {
        let position = MissingView_1.positionMap.get(type);
        if (!position) {
            position = sprotty_protocol_1.Point.ORIGIN;
            MissingView_1.positionMap.forEach(value => position = value.y >= position.y ? { x: 0, y: value.y + 20 } : position);
            MissingView_1.positionMap.set(type, position);
        }
        return position;
    }
};
exports.MissingView = MissingView;
MissingView.positionMap = new Map();
exports.MissingView = MissingView = MissingView_1 = __decorate([
    (0, inversify_1.injectable)()
], MissingView);
//# sourceMappingURL=view.js.map