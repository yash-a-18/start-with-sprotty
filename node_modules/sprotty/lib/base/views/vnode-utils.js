"use strict";
/********************************************************************************
 * Copyright (c) 2017-2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAttrs = exports.on = exports.mergeStyle = exports.copyClassesFromElement = exports.copyClassesFromVNode = exports.setNamespace = exports.setClass = exports.setAttr = void 0;
function setAttr(vnode, name, value) {
    getAttrs(vnode)[name] = value;
}
exports.setAttr = setAttr;
function setClass(vnode, name, value) {
    getClass(vnode)[name] = value;
}
exports.setClass = setClass;
function setNamespace(node, ns) {
    if (node.data === undefined)
        node.data = {};
    node.data.ns = ns;
    const children = node.children;
    if (children !== undefined) {
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (typeof child !== 'string')
                setNamespace(child, ns);
        }
    }
}
exports.setNamespace = setNamespace;
function copyClassesFromVNode(source, target) {
    const classList = getClass(source);
    Object.keys(classList).forEach(c => setClass(target, c, true));
}
exports.copyClassesFromVNode = copyClassesFromVNode;
function copyClassesFromElement(element, target) {
    const classList = element.classList;
    for (let i = 0; i < classList.length; i++) {
        const item = classList.item(i);
        if (item)
            setClass(target, item, true);
    }
}
exports.copyClassesFromElement = copyClassesFromElement;
function mergeStyle(vnode, style) {
    getData(vnode).style = Object.assign(Object.assign({}, (getData(vnode).style || {})), style);
}
exports.mergeStyle = mergeStyle;
function on(vnode, event, listener) {
    const val = getOn(vnode);
    if (val[event]) {
        throw new Error('EventListener for ' + event + ' already registered on VNode');
    }
    val[event] = listener;
}
exports.on = on;
function getAttrs(vnode) {
    const data = getData(vnode);
    if (!data.attrs)
        data.attrs = {};
    return data.attrs;
}
exports.getAttrs = getAttrs;
function getData(vnode) {
    if (!vnode.data)
        vnode.data = {};
    return vnode.data;
}
function getClass(vnode) {
    const data = getData(vnode);
    if (!data.class)
        data.class = {};
    return data.class;
}
function getOn(vnode) {
    const data = getData(vnode);
    if (!data.on)
        data.on = {};
    return data.on;
}
//# sourceMappingURL=vnode-utils.js.map