"use strict";
/********************************************************************************
 * Copyright (c) 2017-2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MousePositionTracker = exports.MouseListener = exports.PopupMouseTool = exports.MouseTool = void 0;
const inversify_1 = require("inversify");
const actions_1 = require("sprotty-protocol/lib/actions");
const smodel_1 = require("../model/smodel");
const types_1 = require("../types");
const dom_helper_1 = require("./dom-helper");
const vnode_utils_1 = require("./vnode-utils");
let MouseTool = class MouseTool {
    constructor(mouseListeners = []) {
        this.mouseListeners = mouseListeners;
    }
    register(mouseListener) {
        this.mouseListeners.push(mouseListener);
    }
    deregister(mouseListener) {
        const index = this.mouseListeners.indexOf(mouseListener);
        if (index >= 0)
            this.mouseListeners.splice(index, 1);
    }
    getTargetElement(model, event) {
        let target = event.target;
        const index = model.index;
        while (target) {
            if (target.id) {
                const element = index.getById(this.domHelper.findSModelIdByDOMElement(target));
                if (element !== undefined)
                    return element;
            }
            target = target.parentNode;
        }
        return undefined;
    }
    handleEvent(methodName, model, event) {
        this.focusOnMouseEvent(methodName, model);
        const element = this.getTargetElement(model, event);
        if (!element)
            return;
        const actions = this.mouseListeners
            .map(listener => listener[methodName](element, event))
            .reduce((a, b) => a.concat(b));
        if (actions.length > 0) {
            event.preventDefault();
            for (const actionOrPromise of actions) {
                if ((0, actions_1.isAction)(actionOrPromise)) {
                    this.actionDispatcher.dispatch(actionOrPromise);
                }
                else {
                    actionOrPromise.then((action) => {
                        this.actionDispatcher.dispatch(action);
                    });
                }
            }
        }
    }
    focusOnMouseEvent(methodName, model) {
        if (document && methodName === 'mouseDown') {
            const domElement = document.getElementById(this.domHelper.createUniqueDOMElementId(model));
            if (domElement !== null && typeof domElement.focus === 'function')
                domElement.focus();
        }
    }
    mouseOver(model, event) {
        this.handleEvent('mouseOver', model, event);
    }
    mouseOut(model, event) {
        this.handleEvent('mouseOut', model, event);
    }
    mouseEnter(model, event) {
        this.handleEvent('mouseEnter', model, event);
    }
    mouseLeave(model, event) {
        this.handleEvent('mouseLeave', model, event);
    }
    mouseDown(model, event) {
        this.handleEvent('mouseDown', model, event);
    }
    mouseMove(model, event) {
        this.handleEvent('mouseMove', model, event);
    }
    mouseUp(model, event) {
        this.handleEvent('mouseUp', model, event);
    }
    wheel(model, event) {
        this.handleEvent('wheel', model, event);
    }
    contextMenu(model, event) {
        event.preventDefault();
        this.handleEvent('contextMenu', model, event);
    }
    doubleClick(model, event) {
        this.handleEvent('doubleClick', model, event);
    }
    decorate(vnode, element) {
        if (element instanceof smodel_1.SModelRootImpl) {
            (0, vnode_utils_1.on)(vnode, 'mouseover', this.mouseOver.bind(this, element));
            (0, vnode_utils_1.on)(vnode, 'mouseout', this.mouseOut.bind(this, element));
            (0, vnode_utils_1.on)(vnode, 'mouseenter', this.mouseEnter.bind(this, element));
            (0, vnode_utils_1.on)(vnode, 'mouseleave', this.mouseLeave.bind(this, element));
            (0, vnode_utils_1.on)(vnode, 'mousedown', this.mouseDown.bind(this, element));
            (0, vnode_utils_1.on)(vnode, 'mouseup', this.mouseUp.bind(this, element));
            (0, vnode_utils_1.on)(vnode, 'mousemove', this.mouseMove.bind(this, element));
            (0, vnode_utils_1.on)(vnode, 'wheel', this.wheel.bind(this, element));
            (0, vnode_utils_1.on)(vnode, 'contextmenu', this.contextMenu.bind(this, element));
            (0, vnode_utils_1.on)(vnode, 'dblclick', this.doubleClick.bind(this, element));
            (0, vnode_utils_1.on)(vnode, 'dragover', (event) => this.handleEvent('dragOver', element, event));
            (0, vnode_utils_1.on)(vnode, 'drop', (event) => this.handleEvent('drop', element, event));
        }
        vnode = this.mouseListeners.reduce((n, listener) => listener.decorate(n, element), vnode);
        return vnode;
    }
    postUpdate() {
    }
};
exports.MouseTool = MouseTool;
__decorate([
    (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
    __metadata("design:type", Object)
], MouseTool.prototype, "actionDispatcher", void 0);
__decorate([
    (0, inversify_1.inject)(types_1.TYPES.DOMHelper),
    __metadata("design:type", dom_helper_1.DOMHelper)
], MouseTool.prototype, "domHelper", void 0);
exports.MouseTool = MouseTool = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.multiInject)(types_1.TYPES.MouseListener)),
    __param(0, (0, inversify_1.optional)()),
    __metadata("design:paramtypes", [Array])
], MouseTool);
let PopupMouseTool = class PopupMouseTool extends MouseTool {
    constructor(mouseListeners = []) {
        super(mouseListeners);
        this.mouseListeners = mouseListeners;
    }
};
exports.PopupMouseTool = PopupMouseTool;
exports.PopupMouseTool = PopupMouseTool = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.multiInject)(types_1.TYPES.PopupMouseListener)),
    __param(0, (0, inversify_1.optional)()),
    __metadata("design:paramtypes", [Array])
], PopupMouseTool);
let MouseListener = class MouseListener {
    mouseOver(target, event) {
        return [];
    }
    mouseOut(target, event) {
        return [];
    }
    mouseEnter(target, event) {
        return [];
    }
    mouseLeave(target, event) {
        return [];
    }
    mouseDown(target, event) {
        return [];
    }
    mouseMove(target, event) {
        return [];
    }
    mouseUp(target, event) {
        return [];
    }
    wheel(target, event) {
        return [];
    }
    doubleClick(target, event) {
        return [];
    }
    contextMenu(target, event) {
        return [];
    }
    dragOver(target, event) {
        return [];
    }
    drop(target, event) {
        return [];
    }
    decorate(vnode, element) {
        return vnode;
    }
};
exports.MouseListener = MouseListener;
exports.MouseListener = MouseListener = __decorate([
    (0, inversify_1.injectable)()
], MouseListener);
let MousePositionTracker = class MousePositionTracker extends MouseListener {
    mouseMove(target, event) {
        this.lastPosition = target.root.parentToLocal({ x: event.offsetX, y: event.offsetY });
        return [];
    }
    /**
     * Returns the last tracked mouse cursor position relative to the diagram root or `undefined`
     * if no mouse cursor position was ever tracked yet.
     */
    get lastPositionOnDiagram() {
        return this.lastPosition;
    }
};
exports.MousePositionTracker = MousePositionTracker;
exports.MousePositionTracker = MousePositionTracker = __decorate([
    (0, inversify_1.injectable)()
], MousePositionTracker);
//# sourceMappingURL=mouse-tool.js.map