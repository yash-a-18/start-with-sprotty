"use strict";
/********************************************************************************
 * Copyright (c) 2017-2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PopupModelViewer = exports.HiddenModelViewer = exports.ModelViewer = exports.PatcherProvider = exports.ModelRenderer = void 0;
/** @jsx html */
const inversify_1 = require("inversify");
const snabbdom_1 = require("snabbdom");
const jsx_1 = require("../../lib/jsx"); // must be html here, as we're creating a div
const browser_1 = require("../../utils/browser");
const initialize_canvas_1 = require("../features/initialize-canvas");
const smodel_factory_1 = require("../model/smodel-factory");
const types_1 = require("../types");
const thunk_view_1 = require("./thunk-view");
const vnode_utils_1 = require("./vnode-utils");
class ModelRenderer {
    constructor(viewRegistry, targetKind, postprocessors, args = {}) {
        this.viewRegistry = viewRegistry;
        this.targetKind = targetKind;
        this.postprocessors = postprocessors;
        this.args = args;
    }
    decorate(vnode, element) {
        if ((0, thunk_view_1.isThunk)(vnode)) {
            return vnode;
        }
        return this.postprocessors.reduce((n, processor) => processor.decorate(n, element), vnode);
    }
    renderElement(element) {
        const view = this.viewRegistry.get(element.type);
        const vnode = view.render(element, this, this.args);
        if (vnode) {
            return this.decorate(vnode, element);
        }
        else {
            return undefined;
        }
    }
    renderChildren(element, args) {
        const context = args ?
            new ModelRenderer(this.viewRegistry, this.targetKind, this.postprocessors, Object.assign(Object.assign({}, args), { parentArgs: this.args })) : this;
        return element.children
            .map(child => context.renderElement(child))
            .filter(vnode => vnode !== undefined);
    }
    postUpdate(cause) {
        this.postprocessors.forEach(processor => processor.postUpdate(cause));
    }
}
exports.ModelRenderer = ModelRenderer;
let PatcherProvider = class PatcherProvider {
    constructor() {
        this.patcher = (0, snabbdom_1.init)(this.createModules());
    }
    createModules() {
        return [
            snabbdom_1.propsModule,
            snabbdom_1.attributesModule,
            snabbdom_1.classModule,
            snabbdom_1.styleModule,
            snabbdom_1.eventListenersModule
        ];
    }
};
exports.PatcherProvider = PatcherProvider;
exports.PatcherProvider = PatcherProvider = __decorate([
    (0, inversify_1.injectable)(),
    __metadata("design:paramtypes", [])
], PatcherProvider);
/**
 * The component that turns the model into an SVG DOM.
 * Uses a VDOM based on snabbdom.js for performance.
 */
let ModelViewer = class ModelViewer {
    constructor(modelRendererFactory, patcherProvider, postprocessors) {
        this.renderer = modelRendererFactory('main', postprocessors);
        this.patcher = patcherProvider.patcher;
    }
    update(model, cause) {
        var _a;
        this.logger.log(this, 'rendering', model);
        const newVDOM = (0, jsx_1.html)("div", { id: this.options.baseDiv }, this.renderer.renderElement(model));
        if (this.lastVDOM !== undefined) {
            const hadFocus = this.hasFocus();
            (0, vnode_utils_1.copyClassesFromVNode)(this.lastVDOM, newVDOM);
            this.lastVDOM = this.patcher.call(this, this.lastVDOM, newVDOM);
            this.restoreFocus(hadFocus);
        }
        else if (typeof document !== 'undefined') {
            let placeholder = null;
            if (this.options.shadowRoot) {
                const shadowRoot = (_a = document.getElementById(this.options.shadowRoot)) === null || _a === void 0 ? void 0 : _a.shadowRoot;
                if (shadowRoot) {
                    placeholder = shadowRoot.getElementById(this.options.baseDiv);
                }
            }
            else {
                placeholder = document.getElementById(this.options.baseDiv);
            }
            if (placeholder !== null) {
                if (typeof window !== 'undefined') {
                    window.addEventListener('resize', () => {
                        this.onWindowResize(newVDOM);
                    });
                }
                (0, vnode_utils_1.copyClassesFromElement)(placeholder, newVDOM);
                (0, vnode_utils_1.setClass)(newVDOM, this.options.baseClass, true);
                this.lastVDOM = this.patcher.call(this, placeholder, newVDOM);
            }
            else {
                this.logger.error(this, 'element not in DOM:', this.options.baseDiv);
            }
        }
        this.renderer.postUpdate(cause);
    }
    hasFocus() {
        if (typeof document !== 'undefined' && document.activeElement && this.lastVDOM.children && this.lastVDOM.children.length > 0) {
            const lastRootVNode = this.lastVDOM.children[0];
            if (typeof lastRootVNode === 'object') {
                const lastElement = lastRootVNode.elm;
                return document.activeElement === lastElement;
            }
        }
        return false;
    }
    restoreFocus(focus) {
        if (focus && this.lastVDOM.children && this.lastVDOM.children.length > 0) {
            const lastRootVNode = this.lastVDOM.children[0];
            if (typeof lastRootVNode === 'object') {
                const lastElement = lastRootVNode.elm;
                if (lastElement && typeof lastElement.focus === 'function')
                    lastElement.focus();
            }
        }
    }
    onWindowResize(vdom) {
        const baseDiv = document.getElementById(this.options.baseDiv);
        if (baseDiv !== null) {
            const newBounds = this.getBoundsInPage(baseDiv);
            this.actiondispatcher.dispatch(initialize_canvas_1.InitializeCanvasBoundsAction.create(newBounds));
        }
    }
    getBoundsInPage(element) {
        const bounds = element.getBoundingClientRect();
        const scroll = (0, browser_1.getWindowScroll)();
        return {
            x: bounds.left + scroll.x,
            y: bounds.top + scroll.y,
            width: bounds.width,
            height: bounds.height
        };
    }
};
exports.ModelViewer = ModelViewer;
__decorate([
    (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
    __metadata("design:type", Object)
], ModelViewer.prototype, "options", void 0);
__decorate([
    (0, inversify_1.inject)(types_1.TYPES.ILogger),
    __metadata("design:type", Object)
], ModelViewer.prototype, "logger", void 0);
__decorate([
    (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
    __metadata("design:type", Object)
], ModelViewer.prototype, "actiondispatcher", void 0);
exports.ModelViewer = ModelViewer = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(types_1.TYPES.ModelRendererFactory)),
    __param(1, (0, inversify_1.inject)(types_1.TYPES.PatcherProvider)),
    __param(2, (0, inversify_1.multiInject)(types_1.TYPES.IVNodePostprocessor)),
    __param(2, (0, inversify_1.optional)()),
    __metadata("design:paramtypes", [Function, PatcherProvider, Array])
], ModelViewer);
/**
 * Viewer for the _hidden_ model. This serves as an intermediate step to compute bounds
 * of elements. The model is rendered in a section that is not visible to the user,
 * and then the bounds are extracted from the DOM.
 */
let HiddenModelViewer = class HiddenModelViewer {
    constructor(modelRendererFactory, patcherProvider, hiddenPostprocessors) {
        this.hiddenRenderer = modelRendererFactory('hidden', hiddenPostprocessors);
        this.patcher = patcherProvider.patcher;
    }
    update(hiddenModel, cause) {
        this.logger.log(this, 'rendering hidden');
        let newVDOM;
        if (hiddenModel.type === smodel_factory_1.EMPTY_ROOT.type) {
            newVDOM = (0, jsx_1.html)("div", { id: this.options.hiddenDiv });
        }
        else {
            const hiddenVNode = this.hiddenRenderer.renderElement(hiddenModel);
            if (hiddenVNode) {
                (0, vnode_utils_1.setAttr)(hiddenVNode, 'opacity', 0);
            }
            newVDOM = (0, jsx_1.html)("div", { id: this.options.hiddenDiv }, hiddenVNode);
        }
        if (this.lastHiddenVDOM !== undefined) {
            (0, vnode_utils_1.copyClassesFromVNode)(this.lastHiddenVDOM, newVDOM);
            this.lastHiddenVDOM = this.patcher.call(this, this.lastHiddenVDOM, newVDOM);
        }
        else {
            let placeholder = document.getElementById(this.options.hiddenDiv);
            if (placeholder === null) {
                placeholder = document.createElement('div');
                document.body.appendChild(placeholder);
            }
            else {
                (0, vnode_utils_1.copyClassesFromElement)(placeholder, newVDOM);
            }
            (0, vnode_utils_1.setClass)(newVDOM, this.options.baseClass, true);
            (0, vnode_utils_1.setClass)(newVDOM, this.options.hiddenClass, true);
            this.lastHiddenVDOM = this.patcher.call(this, placeholder, newVDOM);
        }
        this.hiddenRenderer.postUpdate(cause);
    }
};
exports.HiddenModelViewer = HiddenModelViewer;
__decorate([
    (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
    __metadata("design:type", Object)
], HiddenModelViewer.prototype, "options", void 0);
__decorate([
    (0, inversify_1.inject)(types_1.TYPES.ILogger),
    __metadata("design:type", Object)
], HiddenModelViewer.prototype, "logger", void 0);
exports.HiddenModelViewer = HiddenModelViewer = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(types_1.TYPES.ModelRendererFactory)),
    __param(1, (0, inversify_1.inject)(types_1.TYPES.PatcherProvider)),
    __param(2, (0, inversify_1.multiInject)(types_1.TYPES.HiddenVNodePostprocessor)),
    __param(2, (0, inversify_1.optional)()),
    __metadata("design:paramtypes", [Function, PatcherProvider, Array])
], HiddenModelViewer);
let PopupModelViewer = class PopupModelViewer {
    constructor(modelRendererFactory, patcherProvider, popupPostprocessors) {
        this.modelRendererFactory = modelRendererFactory;
        this.popupRenderer = this.modelRendererFactory('popup', popupPostprocessors);
        this.patcher = patcherProvider.patcher;
    }
    update(model, cause) {
        this.logger.log(this, 'rendering popup', model);
        const popupClosed = model.type === smodel_factory_1.EMPTY_ROOT.type;
        let newVDOM;
        if (popupClosed) {
            newVDOM = (0, jsx_1.html)("div", { id: this.options.popupDiv });
        }
        else {
            const position = model.canvasBounds;
            const inlineStyle = {
                top: position.y + 'px',
                left: position.x + 'px'
            };
            newVDOM = (0, jsx_1.html)("div", { id: this.options.popupDiv, style: inlineStyle }, this.popupRenderer.renderElement(model));
        }
        if (this.lastPopupVDOM !== undefined) {
            (0, vnode_utils_1.copyClassesFromVNode)(this.lastPopupVDOM, newVDOM);
            (0, vnode_utils_1.setClass)(newVDOM, this.options.popupClosedClass, popupClosed);
            this.lastPopupVDOM = this.patcher.call(this, this.lastPopupVDOM, newVDOM);
        }
        else if (typeof document !== 'undefined') {
            let placeholder = document.getElementById(this.options.popupDiv);
            if (placeholder === null) {
                placeholder = document.createElement('div');
                document.body.appendChild(placeholder);
            }
            else {
                (0, vnode_utils_1.copyClassesFromElement)(placeholder, newVDOM);
            }
            (0, vnode_utils_1.setClass)(newVDOM, this.options.popupClass, true);
            (0, vnode_utils_1.setClass)(newVDOM, this.options.popupClosedClass, popupClosed);
            this.lastPopupVDOM = this.patcher.call(this, placeholder, newVDOM);
        }
        this.popupRenderer.postUpdate(cause);
    }
};
exports.PopupModelViewer = PopupModelViewer;
__decorate([
    (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
    __metadata("design:type", Object)
], PopupModelViewer.prototype, "options", void 0);
__decorate([
    (0, inversify_1.inject)(types_1.TYPES.ILogger),
    __metadata("design:type", Object)
], PopupModelViewer.prototype, "logger", void 0);
exports.PopupModelViewer = PopupModelViewer = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(types_1.TYPES.ModelRendererFactory)),
    __param(1, (0, inversify_1.inject)(types_1.TYPES.PatcherProvider)),
    __param(2, (0, inversify_1.multiInject)(types_1.TYPES.PopupVNodePostprocessor)),
    __param(2, (0, inversify_1.optional)()),
    __metadata("design:paramtypes", [Function, PatcherProvider, Array])
], PopupModelViewer);
//# sourceMappingURL=viewer.js.map