"use strict";
/********************************************************************************
 * Copyright (c) 2017-2024 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFeatureSet = exports.EMPTY_ROOT = exports.SModelFactory = exports.SModelRegistry = void 0;
const inversify_1 = require("inversify");
const types_1 = require("../types");
const registry_1 = require("../../utils/registry");
const smodel_1 = require("./smodel");
/**
 * Model element classes registered here are considered automatically when constructring a model from its schema.
 */
let SModelRegistry = class SModelRegistry extends registry_1.FactoryRegistry {
    constructor(registrations) {
        super();
        registrations.forEach(registration => {
            let defaultFeatures = this.getDefaultFeatures(registration.constr);
            if (!defaultFeatures && registration.features && registration.features.enable)
                defaultFeatures = [];
            if (defaultFeatures) {
                const featureSet = createFeatureSet(defaultFeatures, registration.features);
                if (registration.isOverride) {
                    this.override(registration.type, () => {
                        const element = new registration.constr();
                        element.features = featureSet;
                        return element;
                    });
                }
                else {
                    this.register(registration.type, () => {
                        const element = new registration.constr();
                        element.features = featureSet;
                        return element;
                    });
                }
            }
            else {
                if (registration.isOverride) {
                    this.override(registration.type, () => new registration.constr());
                }
                else {
                    this.register(registration.type, () => new registration.constr());
                }
            }
        });
    }
    getDefaultFeatures(constr) {
        let obj = constr;
        do {
            const defaultFeatures = obj.DEFAULT_FEATURES;
            if (defaultFeatures)
                return defaultFeatures;
            obj = Object.getPrototypeOf(obj);
        } while (obj);
        return undefined;
    }
};
exports.SModelRegistry = SModelRegistry;
exports.SModelRegistry = SModelRegistry = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.multiInject)(types_1.TYPES.SModelElementRegistration)),
    __param(0, (0, inversify_1.optional)()),
    __metadata("design:paramtypes", [Array])
], SModelRegistry);
/**
 * The default model factory creates SModelRoot for the root element and SChildElement for all other
 * model elements.
 */
let SModelFactory = class SModelFactory {
    createElement(schema, parent) {
        let child;
        if (this.registry.hasKey(schema.type)) {
            const regElement = this.registry.get(schema.type, undefined);
            if (!(regElement instanceof smodel_1.SChildElementImpl))
                throw new Error(`Element with type ${schema.type} was expected to be an SChildElement.`);
            child = regElement;
        }
        else {
            child = new smodel_1.SChildElementImpl();
        }
        return this.initializeChild(child, schema, parent);
    }
    createRoot(schema) {
        let root;
        if (this.registry.hasKey(schema.type)) {
            const regElement = this.registry.get(schema.type, undefined);
            if (!(regElement instanceof smodel_1.SModelRootImpl))
                throw new Error(`Element with type ${schema.type} was expected to be an SModelRoot.`);
            root = regElement;
        }
        else {
            root = new smodel_1.SModelRootImpl();
        }
        return this.initializeRoot(root, schema);
    }
    createSchema(element) {
        const schema = {};
        for (const key in element) {
            if (!this.isReserved(element, key)) {
                const value = element[key];
                if (typeof value !== 'function')
                    schema[key] = value;
            }
        }
        if (element instanceof smodel_1.SParentElementImpl)
            schema['children'] = element.children.map(child => this.createSchema(child));
        return schema;
    }
    initializeElement(element, schema) {
        for (const key in schema) {
            if (!this.isReserved(element, key)) {
                const value = schema[key];
                if (typeof value !== 'function')
                    element[key] = value;
            }
        }
        return element;
    }
    isReserved(element, propertyName) {
        if (['children', 'parent', 'index'].indexOf(propertyName) >= 0)
            return true;
        let obj = element;
        do {
            const descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
            if (descriptor !== undefined)
                return descriptor.get !== undefined;
            obj = Object.getPrototypeOf(obj);
        } while (obj);
        return false;
    }
    initializeParent(parent, schema) {
        this.initializeElement(parent, schema);
        if ((0, smodel_1.isParent)(schema)) {
            parent.children = schema.children.map(childSchema => this.createElement(childSchema, parent));
        }
        return parent;
    }
    initializeChild(child, schema, parent) {
        this.initializeParent(child, schema);
        if (parent !== undefined) {
            child.parent = parent;
        }
        return child;
    }
    initializeRoot(root, schema) {
        this.initializeParent(root, schema);
        root.index.add(root);
        return root;
    }
};
exports.SModelFactory = SModelFactory;
__decorate([
    (0, inversify_1.inject)(types_1.TYPES.SModelRegistry),
    __metadata("design:type", SModelRegistry)
], SModelFactory.prototype, "registry", void 0);
exports.SModelFactory = SModelFactory = __decorate([
    (0, inversify_1.injectable)()
], SModelFactory);
exports.EMPTY_ROOT = Object.freeze({
    type: 'NONE',
    id: 'EMPTY'
});
function createFeatureSet(defaults, custom) {
    const featureSet = new Set(defaults);
    if (custom && custom.enable) {
        for (const f of custom.enable) {
            featureSet.add(f);
        }
    }
    if (custom && custom.disable) {
        for (const f of custom.disable) {
            featureSet.delete(f);
        }
    }
    return featureSet;
}
exports.createFeatureSet = createFeatureSet;
//# sourceMappingURL=smodel-factory.js.map